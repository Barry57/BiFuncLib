SSVD
=========================

.. _ssvd-label:


Method Description
------------------
- Sparse data representation

SSVD operates on high-dimensional data matrices where rows typically represent samples (e.g., subjects) and columns represent variables (e.g., genes). The data matrix is often centered to ensure that each column has zero mean. This preprocessing step helps in identifying interpretable patterns by removing the overall mean effect.

- Model Definition

SSVD seeks a low-rank, checkerboard-structured matrix approximation to the data matrix \( X \). The checkerboard structure is achieved by imposing sparsity on both the left and right singular vectors, resulting in many zero entries. Specifically, the model aims to decompose \( X \) into a sum of rank-one matrices \( s_k u_k v_k^T \), where \( u_k \) and \( v_k \) are sparse singular vectors. This structure allows for simultaneous clustering of rows and columns, revealing interpretable row-column associations.

- Iterative algorithm for computation

The SSVD algorithm alternates between optimizing the left and right singular vectors while imposing sparsity-inducing penalties. The steps are as follows:

1. Apply standard SVD to the data matrix \( X \) to obtain the initial singular vectors.

2. For fixed \( u \), update \( v \) using a soft-thresholding rule to impose sparsity:

.. math::

   \tilde{v}_j = \text{sign}((X^T u)_j) \left( |(X^T u)_j| - \frac{\lambda_v w_{2,j}}{2} \right)_+

3. For fixed \( v \), update \( u \) similarly:

.. math::

   \tilde{u}_i = \text{sign}((X v)_i) \left( |(X v)_i| - \frac{\lambda_u w_{1,i}}{2} \right)_+

4. Normalize \( u \) and \( v \) and update the singular value \( s \).

5. Repeat the updates until convergence, typically within 5 to 10 iterations. The penalty parameters \( \lambda_u \) and \( \lambda_v \) are selected using the Bayesian Information Criterion (BIC) to balance sparsity and goodness-of-fit.

- Penalty parameter selection

The degrees of sparsity of the singular vectors \( u \) and \( v \) are controlled by the penalty parameters \( \lambda_u \) and \( \lambda_v \). These parameters are selected using the BIC, which balances the model complexity (number of non-zero entries) with the fit to the data. The BIC is defined as:

.. math::

   \text{BIC}(\lambda) = \frac{\|Y - \hat{Y}\|^2}{nd \cdot \hat{\sigma}^2} + \frac{\log(nd)}{nd} \hat{df}(\lambda),

where \( \hat{df}(\lambda) \) is the degree of sparsity (number of non-zero entries) and \( \hat{\sigma}^2 \) is the estimated error variance.

- Post-processing for interpretation

After obtaining the SSVD layers, the resulting sparse singular vectors can be used to identify biclusters. For example, in gene expression data, the non-zero entries in \( u \) and \( v \) indicate which samples and genes are associated within each bicluster. The biclusters can be visualized using image plots or scatter plots of the singular vectors, revealing distinct groupings and contrasts between different conditions or classes.


Function
--------------
This method provides three four functions: **ssvd_sim_data** for simulation, **s4vd_biclus** and **ssvd_biclus** for modeling, and **jaccardmat** for evaluation. For visualization, we use **bcheatmap** function which is the same as **Bimax** to show the clustering result.
In this section, we detail their respective usage, as well as parameters, output values and usage examples for each function. 

ssvd_sim_data
~~~~~~~~~~~~~~~
**ssvd_sim_data** generates a dict contains data matrix and true clustering results.

.. code-block:: python

    ssvd_sim_data()

Parameter
^^^^^^^^^^

The simulated data generates data in a fixed way and have no adjustable parameters.


Value
^^^^^^^^^

- **data**: array, data matrix generated by SSVD model.

- **res**: BiclustResult object, true clustering results.

Example
^^^^^^^^
.. code-block:: python

  from BiFuncLib.simulation_data import ssvd_sim_data
  ssvd_simdata = ssvd_sim_data()



s4vd_biclus and ssvd_biclus
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The **ssvd_biclus** function performs biclustering of the data matrix using sparse singular value decomposition, while **s4vd_biclus** builds upon this by incorporating nested stability selection for enhanced biclustering results.

.. code-block:: python

  ssvd_biclus(data, K=10, threu=1, threv=1, gamu=0, gamv=0, merr=1e-4, niter=100)

and

.. code-block:: python

  s4vd_biclus(data, steps=100, pcerv=0.1, pceru=0.1, ss_thr=(0.6, 0.65), size=0.5, gamm=0, iters=100, nbiclust=10, merr=1e-3, cols_nc=True,  
              rows_nc=True, row_overlap=True, col_overlap=True, row_min=1, col_min=1, pointwise=True, start_iter=3, savepath=False)


Parameter
^^^^^^^^^^
For **ssvd_biclus** function, the parameters are listed below:

.. list-table:: 
   :widths: 30 70
   :header-rows: 1
   :align: center

   * - Parameter
     - Description
   * - **matrix**
     - array, the pre-thresholded binary expression matrix where 1 indicates a gene responds under a condition.
   * - **minr**
     - integer, minimal numbers of rows an inclusion-maximal all-1 submatrix must contain to be reported, filtering out tiny biclusters.
   * - **minc**
     - integer, minimal numbers of columns an inclusion-maximal all-1 submatrix must contain to be reported, filtering out tiny biclusters.
   * - **number**
     - integer, maximum biclusters returned after duplicate removal, set to 100 in the paper for fair cross-method comparison.

For **s4vd_biclus** function, the parameters are listed below:


Value
^^^^^^^^^
The function **bimax_biclus** outputs a BiclustResult object defined within the package.
The key results are **feature_cluster** and **sample_cluster**, and we omitted the outputs that are identical to the inputs.

- **params**: dict, stores the user-supplied parameter dict (minr, minc, number, etc.).

- **RowxNumber**: array, binary matrix indicating which rows belong to which of the K row clusters (1 = member, 0 = non-member).

- **NumberxCol**: array, transposed binary matrix indicating which columns belong to which of the L column clusters.

- **Number**: integer, total number of biclusters returned after filtering,

- **cluster_row_sizes**: integer, the number of rows assigned to each row cluster (obtained as column sums of **RowxNumber**).

- **cluster_col_sizes**: integer, the number of columns assigned to each column cluster (obtained as column sums of **NumberxCol**).



Example
^^^^^^^^
.. code-block:: python

  from BiFuncLib.simulation_data import bimax_sim_data
  from BiFuncLib.bimax_biclus import bimax_biclus
  bimax_simdata = bimax_sim_data()
  bimax_res = bimax_biclus(bimax_simdata, minr=4,minc=4,number=10)


bcheatmap
~~~~~~~~~~~~~~~~~~
**bcheatmap** visualizes the scalar clustering result in the form of a heatmap.

.. code-block:: python

    bcheatmap(X, res, cexR=1.5, cexC=1.25, axisR=False, axisC=True, heatcols=None, clustercols=None,
              allrows=False, allcolumns=True)


Parameter
^^^^^^^^^^
.. list-table:: 
   :widths: 30 70
   :header-rows: 1
   :align: center

   * - Parameter
     - Description
   * - **X**
     - array, the matrix needs to be clustered.
   * - **res**
     - BiclustResult object, the biclustering result object containing information about row and column assignments to biclusters.
   * - **cexR**
     - numeric, the font size of row labels. Default is 1.5.
   * - **cexC**
     - numeric, the font size of column labels. Default is 1.25.
   * - **axisR**
     - bool, whether to show row labels on the heatmap. Default is False.
   * - **axisC**
     - bool, whether to show column labels on the heatmap. Default is True.
   * - **heatcols**
     - str or none, color palette for the heatmap. Default is None which stands for a diverging blue-white-red palette.
   * - **clustercols**
     - list or none, list of colors for outlining biclusters on the heatmap. Default is a list of distinct colors.
   * - **allrows**
     - bool, whether to include all rows in the heatmap, even those not assigned to any bicluster. Default is False.
   * - **allcolumns**
     - bool, whether to include all columns in the heatmap, even those not assigned to any bicluster. Default is True.


Value
^^^^^^^^^
A heatmap will be displayed to show the clustering result.

.. image:: /_static/bimax_res.png
   :width: 400
   :align: center


Example
^^^^^^^^

.. code-block:: python

  from BiFuncLib.simulation_data import bimax_sim_data
  from BiFuncLib.bimax_biclus import bimax_biclus
  from BiFuncLib.bcheatmap import bcheatmap
  bimax_simdata = bimax_sim_data()
  bimax_res = bimax_biclus(bimax_simdata, minr=4,minc=4,number=10)
  bcheatmap(bimax_simdata,bimax_res)
